---
title: "Bayesian Analysis Workshop"
author: "Bill Peterman"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data

![](https://allisonhorst.github.io/palmerpenguins/reference/figures/palmerpenguins.png){width="200"}

For the hands-on portion of the workshop we're going to be using the `palmerpenguins` data set, which includes data on three species of penguin: Chinstrap, Gentoo, and Adelie. From the package:

```         
Description: Size measurements, clutch observations, and blood isotope ratios for adult foraging Ad√©lie, Chinstrap, and Gentoo penguins observed on islands in the Palmer Archipelago near Palmer Station, Antarctica. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. 
```

![](https://allisonhorst.github.io/palmerpenguins/reference/figures/lter_penguins.png)

We're going to primarily focus on species, flipper length, sex, and mass.

## Install & Load Packages

Let's start by downloading the package, then loading the R packages we'll use in this workshop. You'll need to make sure you have all the necessary packages installed.

```{r}
# Install package, if needed
# install.packages("palmerpenguins")

# Load libraries
library(palmerpenguins)
library(brms)
library(bayestestR)
library(bayesplot)
# library(marginaleffects)

# Load data
data("penguins")
dat <- penguins

# Create mass_kg
dat$mass_kg <- dat$body_mass_g/1000
```

## Data Exploration

Let's first get a sense of what the penguin data looks like

```{r cars}
str(dat)
summary(dat)

table(dat$species, 
      dat$sex)
```

## Flipper X Mass Analysis

### Frequentist Model

We'll start by assessing body mass as a function species and flipper length. First, let's fit a frequentist linear model. You'll notice that we are scaling flipper length. This is generally good practice when modeling because it can facilitate model convergence and makes parameter estimates between predictors (when there are multiple predictors) comparable.

```{r}
## Frequentist
m1 <- glm(mass_kg ~ species + scale(flipper_length_mm),
          family = gaussian(),
          data = dat)
summary(m1)
```

What do we see? There is a strong positive relationship between flipper length and body mass. Also, we see that Chinstrap and Gentoo penguins have significantly different body masses when compared to Adelie penguins (the Intercept).

## Bayesian Model -- Uninformed

Now we'll fit a Bayesian model using the default, uninformed priors generated by `brms`. We're going to run 4 chains in parallel (4 cores), with a warmup of 1000 , followed by 1000 samples saved without thinning. I'm also saving fitted model objects using the 'file' command. This is optional, but can come in handy when revisiting code and models in the future.

```{r}
# See what your working directory is
getwd()

# Change / set directory, as needed
# setwd('YOUR_DIRECTORY')

# Bayesian -- uninformed
m2 <- brm(mass_kg ~ species + scale(flipper_length_mm),
          family = gaussian(),
          data = dat,
          file = "models/m2",
          file_refit = 'on_change',
          iter = 2000,
          warmup = 1000,
          thin = 1,
          chains = 4,
          cores = 4)

```

No warnings! That's a good start. We'll inspect the MCMC chains and other model diagnostics to confirm we've got a model that we can comfortably make inference with. The quickest way to inspect posterior distributions and MCMC chains is by simply plotting the fitted model.

#### Traceplots

```{r}
plot(m2)
```

The chains looked mixed and 'fuzzy' and the posterior distributions look good. To check for autocorrelation, we'll use the `mcmc_acf` function from `bayesplot`. This function requires that we extract the MCMC samples and save as an array.

#### MCMC Autocorrelation

```{r}
m2_mcmc <- as.array(m2)
mcmc_acf(m2_mcmc)
```

Nothing out of the ordinary. Next, we'll look at the model summary to determine if we have sufficient samples from the posterior (effective sample size) as well as MCMC chain convergence (R-hat \<= 1.05).

#### Posterior Summary

```{r}
summary(m2)
```

Everything looks good with regards to sample size and R-hat. We see, as expected, that the Bayesian model fit with uninformed priors produces nearly identical parameter estimates. We'll use the `describe_posterior` function from `bayestestR` to further explore our model. Instead of 95% credible interval, however, we'll calculate 95% HDI with this summary.

```{r}
describe_posterior(m2, ci_method = 'HDI')
```

We see there is a \>99% chance that Chinstrap Penguins are smaller than Adelies and there is a \>99% chance that Gentoo are larger than Adelie. What about the difference between Chinstrap and Gentoo? In our current example it's pretty obvious, but testing such differences (probabilistically) is trivial when using a Bayesian framework. We can use the `hypothesis` function from `brms`.

```{r}
# One-sided test
hypothesis(m2, "speciesChinstrap < speciesGentoo")

# Two-sided test
hypothesis(m2, "speciesChinstrap = speciesGentoo")
```

We can also create and test arbitrary hypotheses. Are Chinstrap Penguins less than 4 kg?

```{r}
hypothesis(m2, "Intercept + speciesChinstrap < 4")
```

#### Posterior Predictive Checks

Finally, we'll assess some posterior predictive checks to make sure our model is generating values consistent with the data we measured.

```{r eval=FALSE}
# All the posterior predictice checks available
pp_check(m2, type = 'x')
```

```{r}
# All together
pp_check(m2, type = 'dens_overlay', ndraws = 100)
pp_check(m2, type = 'stat_2d')

## We have groups (species) in our data. We can assess those separately
pp_check(m2, type = 'dens_overlay_grouped', group = 'species',ndraws = 100)

pp_check(m2, type = 'ecdf_overlay_grouped', group = 'species',ndraws = 100)

pp_check(m2, type = 'stat_grouped', group = 'species')
```

Everything looks good. Remember that we used the default, uninformed, priors for this model. Let's see what the default priors were.

#### Plotting Model Effect

```{r}
conditional_effects(m2)
```

#### Inspecting Priors

```{r}
## Uninformed priors
prior_summary(m2)
```

Plot prior distributions (quick and dirty), except for flat priors. These priors give equal probability to all values between a specified upper and lower bound.

```{r}
intercept_prior <- rstudent_t(1e5, 3, 4, 2.5)
sigma_prior <- rstudent_t(1e5, 3, 0, 2.5)

hist(intercept_prior, main = "Intercept prior")
hist(sigma_prior[sigma_prior>0], main = 'sigma prior')

```

## Bayesian Model -- Informed

Being sentient, observant beings of earth, we should be able to provide some reasonable information to our model as prior information. Let's do this and see how / if it changes anything.

#### Specify Priors

There is no reason to believe that as flipper length increases that body mass decreases. Therefore we ensure this prior is always positive. A quick Google search indicates that Adelie Penguins (the Intercept) weigh 3.8--5.8kg. We can specify a prior in the middle of this range (in grams). Finally, a little more research suggests that Gentoo \> Adelie =\> Chinstrap in terms of mass. The one challenge that we have is `brms` is a little limited in how we set boundaries on priors.

```{r}
p3 <- c(prior(normal(1,1), coef = scaleflipper_length_mm),
        prior(normal(-1,1), coef = speciesChinstrap),
        prior(normal(1,1), coef = speciesGentoo),
        prior(normal(4.75,1), class = Intercept), 
        prior(exponential(1), class = sigma))
```

Take a quick look at what each of the priors look like. This process can be a little iterative.

```{r}
hist(rnorm(1e5,1,1), main = 'Flipper Prior')
hist(rnorm(1e5,-1,1), main = 'Chinstrap Prior')
hist(rnorm(1e5,1,1), main = 'Gentoo Prior')
hist(rnorm(1e5,4.75,1), main = 'Intercept Prior')
hist(rexp(1e5,1), main = 'sigma Prior')
```

Before we fully add the priors to our model, it can be a good sanity check to make sure that the specified priors generate values that are sensible. We can evaluate this using *prior predictive checks*. These are the same as the posterior predictive checks we used above, but done from samples taken **only** from the specified prior distributions.

```{r}
# Bayesian -- prior
m3.prior <- brm(mass_kg ~ species + scale(flipper_length_mm),
                family = gaussian(),
                data = dat,
                file = "models/m3_prior",
                file_refit = 'on_change',
                prior = p3,
                sample_prior = 'only', ## For prior checks
                iter = 2000,
                warmup = 1000,
                thin = 1,
                chains = 4,
                cores = 4)

## Now look at checks
## Hopefully see that the priors are approximating the data we observed
pp_check(m3.prior, type = 'dens_overlay', ndraws = 100)
pp_check(m3.prior, type = 'ecdf_overlay_grouped', group = 'species',ndraws = 100)
pp_check(m3.prior, type = 'stat_grouped', group = 'species')
```

Seems that our priors are doing a good job. We can now update our posterior estimates to include the data in our model. Add the priors to your model.

```{r}
# Bayesian -- Informed
m3 <- brm(mass_kg ~ species + scale(flipper_length_mm),
          family = gaussian(),
          data = dat,
          file = "models/m3",
          file_refit = 'on_change',
          prior = p3,
          # sample_prior = 'only', ## For prior checks
          iter = 2000,
          warmup = 1000,
          thin = 1,
          chains = 4,
          cores = 4)


```

***Compare the parameter estimates of the model with informed priors to the model with uninformed priors. Have priors altered the estimates?***

#### Misinformed Priors

What if our prior beliefs were incorrect? Let's see how strong, misinformed prior affects parameters estimates.

```{r}
# Mass decreases with flipper length
# Chinstrap Penguins are larger than Adelie
p4 <- c(prior(normal(-5,1), coef = scaleflipper_length_mm),
        prior(normal(2,0.5), coef = speciesChinstrap),
        prior(normal(1,1), coef = speciesGentoo),
        prior(normal(4.75,1), class = Intercept), 
        prior(exponential(1), class = sigma))

m4 <- brm(mass_kg ~ species + scale(flipper_length_mm),
          family = gaussian(),
          data = dat,
          file = "models/m4",
          file_refit = 'on_change',
          prior = p4,
          iter = 2000,
          warmup = 1000,
          thin = 1,
          chains = 4,
          cores = 4)
```

## Explore and Model!

If you've gotten this far and want to do more, some possible models/questions are identified below. For any of these, consider how and where you could specify priors.

-   Does mass of Adelie penguins differ among the sampled islands?

```{r}
# Extract Adelie observations 
adelie_dat <- dat[dat$species == 'Adelie',]

# Formula
# mass_kg ~ island
```

-   Does mass of Adelie penguins differ among years?

    ```{r}
    # Extract Adelie observations 
    adelie_dat <- dat[dat$species == 'Adelie',]

    # Formula
    # mass_kg ~ as.factor(year)
    ```

-   Model mass as a function of sex, species, and flipper length. Include a `species * sex` interaction

    ```{r}
    # Formula
    # mass_kg ~ sex * species + scale(flipper_length_mm)

    m4 <- glm(mass_kg ~ sex * species + scale(flipper_length_mm),
              data = dat)

    m4.b <- brm(mass_kg ~ sex * species + scale(flipper_length_mm),
                data = dat)
    ```
